diff --git a/src/Components/Web.JS/src/Boot.WebAssembly.Common.ts b/src/Components/Web.JS/src/Boot.WebAssembly.Common.ts
index f6d3824f32..700490eb6f 100644
--- a/src/Components/Web.JS/src/Boot.WebAssembly.Common.ts
+++ b/src/Components/Web.JS/src/Boot.WebAssembly.Common.ts
@@ -18,6 +18,10 @@ import { MonoConfig } from 'dotnet';
 import { RootComponentManager } from './Services/RootComponentManager';
 import { WebRendererId } from './Rendering/WebRendererId';
 
+// B.W.S: Import the function used to configure the navigation base URL used by the Blazor
+// Navigation Manager.
+import { setNavigationBaseUrl } from './Services/NavigationUtils';
+
 let options: Partial<WebAssemblyStartOptions> | undefined;
 let initializersPromise: Promise<void>;
 let platformLoadPromise: Promise<void> | undefined;
@@ -128,25 +132,13 @@ async function startCore(components: RootComponentManager<WebAssemblyComponentDe
     }
   };
 
-  Blazor._internal.navigationManager.listenForNavigationEvents(WebRendererId.WebAssembly, async (uri: string, state: string | undefined, intercepted: boolean): Promise<void> => {
-    await dispatcher.invokeDotNetStaticMethodAsync(
-      'Microsoft.AspNetCore.Components.WebAssembly',
-      'NotifyLocationChanged',
-      uri,
-      state,
-      intercepted
-    );
-  }, async (callId: number, uri: string, state: string | undefined, intercepted: boolean): Promise<void> => {
-    const shouldContinueNavigation = await dispatcher.invokeDotNetStaticMethodAsync<boolean>(
-      'Microsoft.AspNetCore.Components.WebAssembly',
-      'NotifyLocationChangingAsync',
-      uri,
-      state,
-      intercepted
-    );
-
-    Blazor._internal.navigationManager.endLocationChanging(callId, shouldContinueNavigation);
-  });
+  // B.W.S: Configure the navigation base URL used by the Blazor Navigation Manager prior to
+  // starting the Blazor application.
+  setNavigationBaseUrl(options?.navigationBaseUrl ?? new URL(document.baseURI));
+
+  // B.W.S: The original direct call to the navigation manager's listenForNavigationEvents function
+  // is now factored to the addNavigationEventListeners function that is called here.
+  addWebAssemblyNavigationEventListeners();
 
   // Leverage the time while we are loading boot.config.json from the network to discover any potentially registered component on
   // the document.
@@ -229,6 +221,36 @@ export function hasLoadedWebAssemblyPlatform(): boolean {
   return loadedWebAssemblyPlatform;
 }
 
+// B.W.S: This adds the navigation event listeners used by the Blazor WebAssembly renderer. In the
+// original code, the call to listenForNavigationEvents was done directly in the startCore function,
+// but it was moved here to make it possible for this function to be called from the mount lifecycle
+// hook of a Blazor micro-frontend when single-spa remounts it to the page.
+export function addWebAssemblyNavigationEventListeners() {
+  Blazor._internal.navigationManager.listenForNavigationEvents(
+    WebRendererId.WebAssembly,
+    async (uri: string, state: string | undefined, intercepted: boolean): Promise<void> => {
+      await dispatcher.invokeDotNetStaticMethodAsync(
+        'Microsoft.AspNetCore.Components.WebAssembly',
+        'NotifyLocationChanged',
+        uri,
+        state,
+        intercepted
+      );
+    },
+    async (callId: number, uri: string, state: string | undefined, intercepted: boolean): Promise<void> => {
+      const shouldContinueNavigation = await dispatcher.invokeDotNetStaticMethodAsync<boolean>(
+        'Microsoft.AspNetCore.Components.WebAssembly',
+        'NotifyLocationChangingAsync',
+        uri,
+        state,
+        intercepted
+      );
+
+      Blazor._internal.navigationManager.endLocationChanging(callId, shouldContinueNavigation);
+    }
+  );
+}
+
 // obsolete, legacy, don't use for new code!
 function invokeJSFromDotNet(callInfo: Pointer, arg0: any, arg1: any, arg2: any): any {
   const functionIdentifier = monoPlatform.readStringField(callInfo, 0)!;
diff --git a/src/Components/Web.JS/src/Boot.WebAssembly.ts b/src/Components/Web.JS/src/Boot.WebAssembly.ts
index bd8e556096..2561ae74e1 100644
--- a/src/Components/Web.JS/src/Boot.WebAssembly.ts
+++ b/src/Components/Web.JS/src/Boot.WebAssembly.ts
@@ -20,7 +20,16 @@ async function boot(options?: Partial<WebAssemblyStartOptions>): Promise<void> {
   }
   started = true;
 
-  setWebAssemblyOptions(Promise.resolve(options || {}));
+  // B.W.S: Ensure navigation and asset base URLs default to the current page's base URL to preserve
+  // as much as possible Blazor's default behavior. Also, set the base URL Microsoft.JSInterop.JS
+  // will use when resolving relative or absolute URL paths to dynamically imported JavaScript
+  // modules so that any dynamic imports triggered by the Blazor application starting can properly
+  // locate their resources.
+  options ??= {};
+  options.assetBaseUrl ??= new URL(document.baseURI);
+  options.navigationBaseUrl ??= new URL(document.baseURI);
+  DotNet.setImportBaseUrl(options.assetBaseUrl);
+  setWebAssemblyOptions(Promise.resolve(options));
 
   JSEventRegistry.create(Blazor);
   const webAssemblyComponents = discoverComponents(document, 'webassembly') as WebAssemblyComponentDescriptor[];
diff --git a/src/Components/Web.JS/src/GlobalExports.ts b/src/Components/Web.JS/src/GlobalExports.ts
index 4af7b56fbf..ea3954f8be 100644
--- a/src/Components/Web.JS/src/GlobalExports.ts
+++ b/src/Components/Web.JS/src/GlobalExports.ts
@@ -44,6 +44,15 @@ export interface IBlazor {
   rootComponents: typeof RootComponentsFunctions;
   runtime: RuntimeAPI,
 
+  // B.W.S:
+  ensureDomListenersReady?: () => void;
+
+  // B.W.S:
+  ensureRootComponentsDisposed?: () => Promise<void>;
+
+  // B.W.S:
+  ensureDomListenersRemoved?: () => void;
+
   _internal: {
     navigationManager: typeof navigationManagerInternalFunctions | any;
     domWrapper: typeof domFunctions;
diff --git a/src/Components/Web.JS/src/JSInitializers/JSInitializers.WebAssembly.ts b/src/Components/Web.JS/src/JSInitializers/JSInitializers.WebAssembly.ts
index ff5bc46426..0e843fea65 100644
--- a/src/Components/Web.JS/src/JSInitializers/JSInitializers.WebAssembly.ts
+++ b/src/Components/Web.JS/src/JSInitializers/JSInitializers.WebAssembly.ts
@@ -21,7 +21,9 @@ export async function fetchAndInvokeInitializers(options: Partial<WebAssemblySta
       WebRendererId.WebAssembly
     );
     const initializers = Object.keys((loadedConfig?.resources?.['libraryInitializers']) || {});
-    await jsInitializer.importInitializersAsync(initializers, initializerArguments);
+    // B.W.S: Pass down the asset base URL to the initializer so that it can resolve relative and
+    // absolute URL paths to the initializer's module.
+    await jsInitializer.importInitializersAsync(initializers, initializerArguments, options.assetBaseUrl);
     return jsInitializer;
   }
 }
diff --git a/src/Components/Web.JS/src/JSInitializers/JSInitializers.ts b/src/Components/Web.JS/src/JSInitializers/JSInitializers.ts
index 9b0089c2e7..37f63b25a3 100644
--- a/src/Components/Web.JS/src/JSInitializers/JSInitializers.ts
+++ b/src/Components/Web.JS/src/JSInitializers/JSInitializers.ts
@@ -38,14 +38,29 @@ export class JSInitializer {
     }
   }
 
-  async importInitializersAsync(initializerFiles: string[], initializerArguments: unknown[]): Promise<void> {
+  async importInitializersAsync(initializerFiles: string[], initializerArguments: unknown[], assetBaseUrl?: URL): Promise<void> {
     // This code is not called on WASM, because library intializers are imported by runtime.
 
+    // B.W.S: Similar to all other assets loaded by a Blazor micro-frontend, the JavaScript
+    // initializer may be hosted at a different URL than the page's base URL. Thus, we need to allow
+    // for the absolute and relative paths to the initializer's module to be resolved against a
+    // custom asset base URL if one is provided.
+    //
+    // NOTE: Even though the original comment above says this code is not called in the WASM case,
+    // it looks like this code is executed by the other variants of Blazor (Blazor Web App, Blazor
+    // Server, etc.). Looking to the future, it's possible the changes provided by B.W.S. can also
+    // be applied to at least the Blazor Web App case when the interactive client render mode is
+    // enabled. To prepare for that, we proactively ensure our custom asset base URL is applied here
+    // and fallback to the document's base URL if one is not provided in order to preserve Blazor's
+    // original behavior.
+    const initializerBaseUrl = (assetBaseUrl ?? new URL(document.baseURI)).toString();
+
     await Promise.all(initializerFiles.map(f => importAndInvokeInitializer(this, f)));
 
     function adjustPath(path: string): string {
       // This is the same we do in JS interop with the import callback
-      const base = document.baseURI;
+      // B.W.S: Apply the base URL computed above to use when importing the initializer's module.
+      const base = initializerBaseUrl;
       path = base.endsWith('/') ? `${base}${path}` : `${base}/${path}`;
       return path;
     }
diff --git a/src/Components/Web.JS/src/Platform/WebAssemblyStartOptions.ts b/src/Components/Web.JS/src/Platform/WebAssemblyStartOptions.ts
index 1a0af87a0e..f472b37731 100644
--- a/src/Components/Web.JS/src/Platform/WebAssemblyStartOptions.ts
+++ b/src/Components/Web.JS/src/Platform/WebAssemblyStartOptions.ts
@@ -30,6 +30,58 @@ export interface WebAssemblyStartOptions {
 
   initializers?: WebAssemblyInitializers;
 
+  /**
+   * B.W.S: Base URL that will be used when resolving both relative URL paths and absolute URL
+   * paths to assets loaded by either Blazor or the .NET browser (WASM) runtime. These assets are
+   * typically things like assemblies, runtime configuration files, and globalization data. It also
+   * includes any JavaScript modules dynamically imported by Blazor via Microsoft.JSInterop.JS;
+   * however, it won't cover JS modules dynamically imported via .NET browser runtime. It hasn't
+   * been verified yet, but it appears that the .NET browser runtime will give a custom resource
+   * loader the chance to resolve an alternate URL for those assets. If that's the case, then the
+   * custom resource loader could apply the asset base URL to resolve those URLs.
+   *
+   * If this is not provided, then this will default to document.baseURI, which is what Blazor and
+   * the .NET browser runtime either directly use or implicitly assume when resolving relative and
+   * absolute path URLs to assets. Ig given, this must end in a trailing slash.
+   *
+   * Rationale: Different micro-frontends, whether implemented by Blazor or not, will typically be
+   * hosted at different URLs that don't necessarily (and most likely won't) match the page's base
+   * URL. Thus, when a Blazor micro-frontend's assets are fetched or its modules dynamically
+   * imported by relative or absolute URL paths, we need to ensure that those assets are ultimately
+   * retrieved from the proper location.
+   *
+   * NOTE: There appear to be some cases in the .NET browser runtime where an asset will be
+   * retrieved using a custom fetch_like function. Internally, it appears this function will use the
+   * global fetch function, but it will specifically set its credentials option to 'same-origin'.
+   * The running theory is that if this is true and if the assets retrieved using this fetch_like
+   * are processed by a custom resource loader that returned an alternate URL, then the loader would
+   * need to possibly ensure the alternate URL is at the same origin as the page if it required
+   * credentials (e.g., cookies) to be sent with the request. Furthermore, it may be possible that
+   * some of those assets, when loaded by a custom resource loader, must resolve to URL strings as
+   * opposed to, e.g., Response objects wrapped in a Promise. If this turns out to be true, then it
+   * would mean that the asset base URL and any custom resource loader must resolve URLs that are
+   * hosted at the same origin as the page.
+   */
+  assetBaseUrl?: URL;
+
+  /**
+   * B.W.S: Base URL the Blazor navigation manager will use internal routing decisions. If not
+   * given, defaults to document.baseURI, which is what Blazor uses directly by default. If given,
+   * this must end in a trailing slash.
+   *
+   * Rationale: Different Blazor micro-frontends managed by single-spa will live at different
+   * client-side routes, e.g., https://example.com/blazor-foo/ and https://example.com/blazor-bar/.
+   * The page's base URL (given by document.baseURI) will typically be simply https://example.com/
+   * (if it is explicitly set by the page's HTML) or will be inferred from the page's current
+   * location. Neither or these will be suitable for both Blazor micro-frontends when their
+   * respective navigation managers attempt to determine 1) if a particular navigation to a new URL
+   * should be considered internal to the Blazor application or external and 2) what the new URL
+   * should be in the case of an internal navigation. Providing a navigation base URL allows the
+   * app developer to specify an appropriate URL that the Blazor navigation manager can use when
+   * making its internal routing decisions.
+   */
+  navigationBaseUrl?: URL;
+
   /**
    * Allows to override .NET runtime configuration.
    */
diff --git a/src/Components/Web.JS/src/Services/NavigationManager.ts b/src/Components/Web.JS/src/Services/NavigationManager.ts
index 7a6e0bbbbf..5be35fb02b 100644
--- a/src/Components/Web.JS/src/Services/NavigationManager.ts
+++ b/src/Components/Web.JS/src/Services/NavigationManager.ts
@@ -4,11 +4,15 @@
 import '@microsoft/dotnet-js-interop';
 import { resetScrollAfterNextBatch } from '../Rendering/Renderer';
 import { EventDelegator } from '../Rendering/Events/EventDelegator';
-import { attachEnhancedNavigationListener, getInteractiveRouterRendererId, handleClickForNavigationInterception, hasInteractiveRouter, hasProgrammaticEnhancedNavigationHandler, isWithinBaseUriSpace, performProgrammaticEnhancedNavigation, setHasInteractiveRouter, toAbsoluteUri } from './NavigationUtils';
+import { attachEnhancedNavigationListener, detachEnhancedNavigationListener, getInteractiveRouterRendererId, handleClickForNavigationInterception, hasInteractiveRouter, hasProgrammaticEnhancedNavigationHandler, isWithinBaseUriSpace, performProgrammaticEnhancedNavigation, setHasInteractiveRouter, toAbsoluteUri } from './NavigationUtils';
 import { WebRendererId } from '../Rendering/WebRendererId';
 import { isRendererAttached } from '../Rendering/WebRendererInteropMethods';
 import { IBlazor } from '../GlobalExports';
 
+// B.W.S: Import the navigation base URL so that it can be returned by the navigation manager's
+// internal API.
+import { navigationBaseUrl } from './NavigationUtils';
+
 let hasRegisteredNavigationEventListeners = false;
 let currentHistoryIndex = 0;
 let currentLocationChangingCallId = 0;
@@ -33,7 +37,8 @@ export const internalFunctions = {
   endLocationChanging,
   navigateTo: navigateToFromDotNet,
   refresh,
-  getBaseURI: (): string => document.baseURI,
+  // B.W.S: Use the configured navigation base URL as the value reported by the navigation manager.
+  getBaseURI: (): string => navigationBaseUrl.toString(),
   getLocationHref: (): string => location.href,
   scrollToElement,
 };
@@ -63,6 +68,22 @@ function listenForNavigationEvents(
   });
 }
 
+// B.W.S: When a Blazor micro-frontend is unmounted from the page by single-spa, we need to ensure
+// that its navigation manager is no longer responding to any DOM events it cares about for
+// navigation purposes. This is essentially the inverse of listenForNavigationEvents, and it is
+// intended to be called by the Blazor micro-frontend's unmount lifecycle hook.
+export function removeNavigationEventListeners(rendererId: WebRendererId) {
+  navigationCallbacks.delete(rendererId);
+
+  if (!hasRegisteredNavigationEventListeners) {
+    return;
+  }
+
+  hasRegisteredNavigationEventListeners = false;
+  window.removeEventListener('popstate', onPopState);
+  detachEnhancedNavigationListener();
+}
+
 function setHasLocationChangingListeners(rendererId: WebRendererId, hasListeners: boolean) {
   const callbacks = navigationCallbacks.get(rendererId);
   if (!callbacks) {
diff --git a/src/Components/Web.JS/src/Services/NavigationUtils.ts b/src/Components/Web.JS/src/Services/NavigationUtils.ts
index a278ac5414..6c74c3810a 100644
--- a/src/Components/Web.JS/src/Services/NavigationUtils.ts
+++ b/src/Components/Web.JS/src/Services/NavigationUtils.ts
@@ -7,6 +7,14 @@ let interactiveRouterRendererId: WebRendererId | undefined = undefined;
 let programmaticEnhancedNavigationHandler: typeof performProgrammaticEnhancedNavigation | undefined;
 let enhancedNavigationListener: typeof notifyEnhancedNavigationListners | undefined;
 
+// B.W.S: We store the navigation base URL here and make it available for other components, notably
+// the Blazor navigation manager, to import and use it. To preserve as much as possible Blazor's
+// default behavior, we set the navigation base URL to the current page's base URL.
+export let navigationBaseUrl: URL = new URL(document.baseURI);
+export function setNavigationBaseUrl(baseUrl: URL) {
+  navigationBaseUrl = baseUrl;
+}
+
 /**
  * Checks if a click event corresponds to an <a> tag referencing a URL within the base href, and that interception
  * isn't bypassed (e.g., by a 'download' attribute or the user holding a meta key while clicking).
@@ -40,7 +48,10 @@ export function handleClickForNavigationInterception(event: MouseEvent, callback
 }
 
 export function isWithinBaseUriSpace(href: string) {
-  const baseUriWithoutTrailingSlash = toBaseUriWithoutTrailingSlash(document.baseURI!);
+  // B.W.S: Compute the base URL using configured navigation base URL. Original code explicitly used
+  // the page's base URL, which is what the navigation base URL will default to as a way of
+  // preserving Blazor's original behavior as much as possible.
+  const baseUriWithoutTrailingSlash = toBaseUriWithoutTrailingSlash(navigationBaseUrl.toString());
   const nextChar = href.charAt(baseUriWithoutTrailingSlash.length);
 
   return href.startsWith(baseUriWithoutTrailingSlash)
@@ -51,6 +62,12 @@ export function attachEnhancedNavigationListener(listener: typeof enhancedNaviga
   enhancedNavigationListener = listener;
 }
 
+// B.W.S: This is a new function that allows the Blazor navigation manager to detach the enhanced
+// navigation listener whenever the navigation manager unregisters its navigation event listeners.
+export function detachEnhancedNavigationListener() {
+  enhancedNavigationListener = undefined;
+}
+
 export function notifyEnhancedNavigationListners(internalDestinationHref: string, interceptedLink: boolean) {
   enhancedNavigationListener?.(internalDestinationHref, interceptedLink);
 }
@@ -78,7 +95,15 @@ function toBaseUriWithoutTrailingSlash(baseUri: string) {
 let testAnchor: HTMLAnchorElement;
 export function toAbsoluteUri(relativeUri: string): string {
   testAnchor = testAnchor || document.createElement('a');
-  testAnchor.href = relativeUri;
+  // B.W.S: The original implementation simply set the test anchor's href attribute to the given
+  // relative URL. Doing so will cause the browser to resolve the anchor's href to the page's base
+  // URL. In the case of a Blazor micro-frontend, the page's base URL does not necessarily
+  // correspond with the navigation base URL used by the Blazor application's navigation manager.
+  // Since toAbsoluteUri is primarily used for building URLs that are then tested to determine if
+  // Blazor should perform an internal or external navigation, we always apply the navigation base
+  // URL when setting the test anchor's href. When the default navigation base URL is used, it will
+  // apply the page's base URL, which preserves as much as possible Blazor's original behavior.
+  testAnchor.href = new URL(relativeUri, navigationBaseUrl).toString();
   return testAnchor.href;
 }
 
diff --git a/src/JSInterop/Microsoft.JSInterop.JS/src/src/Microsoft.JSInterop.ts b/src/JSInterop/Microsoft.JSInterop.JS/src/src/Microsoft.JSInterop.ts
index 4a237e391c..402ec3b9f6 100644
--- a/src/JSInterop/Microsoft.JSInterop.JS/src/src/Microsoft.JSInterop.ts
+++ b/src/JSInterop/Microsoft.JSInterop.JS/src/src/Microsoft.JSInterop.ts
@@ -71,8 +71,38 @@ export module DotNet {
       // In most cases developers will want to resolve dynamic imports relative to the base HREF.
       // However since we're the one calling the import keyword, they would be resolved relative to
       // this framework bundle URL. Fix this by providing an absolute URL.
-      if (typeof url === "string" && url.startsWith("./")) {
-          url = new URL(url.substr(2), document.baseURI).toString();
+      if (typeof url === "string") {
+          if (url.startsWith("./")) {
+              // B.W.S: The given URL is a relative URL path. Blazor's intent in this case is to
+              // resolve it against the apps "base HREF". The original code used document.baseURI
+              // and also had the implicit assumption that the page's base HREF ended with a
+              // trailing slash. This would ensure the URL concatenation formed the correct absolute
+              // URL when using the URL constructor.
+              //
+              // In our case, we concatenate with the importBaseUrl the app developer provides when
+              // they specify the assetBaseUrl to Blazor.start. Out of a desire to not deviate too
+              // much from the original code, we will assume that the importBaseUrl will always end
+              // with a trailing slash rather than forcing a trailing slash on the import base URL
+              // if it's missing.
+              //
+              // NOTE: The original code stripped the leading "./" from the URL. We don't do that
+              // here because it's not necessary. The URL will be resolved correctly by the URL
+              // constructor regardless of whether the leading "./" is present or not.
+              url = new URL(url, importBaseUrl).toString();
+          } else if (url.startsWith("/")) {
+              // B.W.S: The given URL is an absolute URL path. In the original code, this would have
+              // been passed directly to the dynamic import below, resulting in the import fetching
+              // the JavaScript module from the root of the page's origin itself.
+              //
+              // However, in the case of a Blazor application managed by single-spa, it's typical
+              // that the application is hosting its assets at a location that differs from the root
+              // of the page's origin. When resolving the absolute path URL, we form a URL that
+              // takes the configured import base URL and concatenates the given absolute path URL
+              // to it. Since we assume the import base URL has a trailing slash, we DO need to trim
+              // off the leading slash in order for the final absolute URL to preserve any path base
+              // the import base URL contains.
+              url = new URL(url.substring(1), importBaseUrl).toString();
+          }
       }
 
       return import(/* webpackIgnore: true */ url);
@@ -686,4 +716,16 @@ export module DotNet {
 
       return value;
   }
+
+  // B.W.S: The importBaseUrl will be used when converting relative and absolute path URLs to
+  // absolute URLs (ones that include the scheme, host, port, and app base path etc.). These are
+  // then used when resolving dynamic imports in the import function registered for invocation from
+  // .NET code running in the browser. The original code used document.baseURI as the base URL when
+  // resolving dynamic imports, thus we choose to initialize the importBaseUrl to that value to
+  // preserve as much as possible Blazor's default behavior.
+  let importBaseUrl: URL = new URL(document.baseURI);
+
+  export function setImportBaseUrl(url: URL) {
+    importBaseUrl = url;
+  }
 }
