diff --git a/src/Components/Web.JS/src/Rendering/BrowserRenderer.ts b/src/Components/Web.JS/src/Rendering/BrowserRenderer.ts
index 7496dd5522..635555680e 100644
--- a/src/Components/Web.JS/src/Rendering/BrowserRenderer.ts
+++ b/src/Components/Web.JS/src/Rendering/BrowserRenderer.ts
@@ -84,6 +84,7 @@ export class BrowserRenderer {
   }

   public disposeComponent(componentId: number): void {
+    console.log('Calling disposeComponent for component', componentId);
     if (this.rootComponentIds.delete(componentId)) {
       // When disposing a root component, the container element won't be removed from the DOM (because there's
       // no parent to remove that child), so we empty it to restore it to the state it was in before the root
@@ -99,6 +100,8 @@ export class BrowserRenderer {
     }

     delete this.childComponentLocations[componentId];
+    console.log('Called disposeComponent for component', componentId);
+    console.log('After disposeComponent, root component count is', this.rootComponentIds.size);
   }

   public disposeEventHandler(eventHandlerId: number): void {
diff --git a/src/Components/Web.JS/src/Rendering/JSRootComponents.ts b/src/Components/Web.JS/src/Rendering/JSRootComponents.ts
index a18a7f2d6c..a838f5bf11 100644
--- a/src/Components/Web.JS/src/Rendering/JSRootComponents.ts
+++ b/src/Components/Web.JS/src/Rendering/JSRootComponents.ts
@@ -104,7 +104,9 @@ class DynamicRootComponent {

   async dispose() {
     if (this._componentId !== null) {
+      console.log('Calling dispose on component', this._componentId);
       await getRequiredManager().invokeMethodAsync('RemoveRootComponent', this._componentId);
+      console.log('Called dispose on component', this._componentId);
       this._componentId = null; // Ensure it can't be used again

       for (const jsEventCallbackWrapper of this._jsEventCallbackWrappers.values()) {
diff --git a/src/JSInterop/Microsoft.JSInterop.JS/src/src/Microsoft.JSInterop.ts b/src/JSInterop/Microsoft.JSInterop.JS/src/src/Microsoft.JSInterop.ts
index 4a237e391c..d1d2839ec9 100644
--- a/src/JSInterop/Microsoft.JSInterop.JS/src/src/Microsoft.JSInterop.ts
+++ b/src/JSInterop/Microsoft.JSInterop.JS/src/src/Microsoft.JSInterop.ts
@@ -71,8 +71,34 @@ export module DotNet {
       // In most cases developers will want to resolve dynamic imports relative to the base HREF.
       // However since we're the one calling the import keyword, they would be resolved relative to
       // this framework bundle URL. Fix this by providing an absolute URL.
-      if (typeof url === "string" && url.startsWith("./")) {
-          url = new URL(url.substr(2), document.baseURI).toString();
+      if (typeof url === "string") {
+          if (url.startsWith("./")) {
+              // B.W.S: The given URL is a relative URL path. Blazor's intent in this case is to
+              // resolve it against the apps "base HREF". The original code used document.baseURI
+              // and also had the implicit assumption that the page's base HREF ended with a
+              // trailing slash. This would ensure the URL concatenation formed the correct full
+              // absolute URL when using the URL constructor.
+              //
+              // In our case, we concatenate with the importBaseUrl provided by B.W.S and that can
+              // be be optionally called by the developer when bootstrapping the app. Out of a
+              // desire to not deviate too much from the original code, we will assume that the
+              // importBaseUrl will always end with a trailing slash.
+              //
+              // NOTE: The original code stripped the leading "./" from the URL. We don't do that
+              // here because it's not necessary. The URL will be resolved correctly by the URL
+              // constructor regardless of whether the leading "./" is present or not.
+              url = new URL(url, importBaseUrl).toString();
+          }
+          else if (url.startsWith("/")) {
+              // B.W.S: The given URL is an absolute URL path. In the original code, this would have
+              // been passed directly to the dynamic import below. However, in our case of a Blazor
+              // application mounted in a single-spa application at a non-root path, we need to
+              // ensure the URL is resolved relative to that mount point. The developer specifies
+              // this when they configure the importBaseUrl, so we use that here. In this case, we
+              // DO need to trim off the leading slash in order for the full absolute URL to be
+              // resolved correctly by the URL constructor.
+              url = new URL(url.substring(1), importBaseUrl).toString();
+          }
       }

       return import(/* webpackIgnore: true */ url);
@@ -686,4 +712,14 @@ export module DotNet {

       return value;
   }
+
+  // B.W.S: The importBaseUrl will be used when converting relative and absolute path URLs to full
+  // absolute URLs (ones that include the scheme, host, port, and app base path etc.). These are
+  // then used when resolving dynamic imports in the import function registered for invocation from
+  // .NET code running in the browser. The original code used document.baseURI as the base URL when
+  // resolving dynamic imports, thus we choose to initialize the importBaseUrl to that value.
+  let importBaseUrl = document.baseURI;
+  export function setImportBaseUrl(url: string) {
+    importBaseUrl = url;
+  }
 }
